<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Chiếu YouTube Receiver</title>
    <style>
        html, body {
            margin: 0; padding: 0; width: 100%; height: 100%;
            background-color: #000; overflow: hidden;
        }
        #player { width: 100vw; height: 100vh; }
        #overlay-container {
            position: absolute; top: 20px; left: 0;
            width: 100%; overflow: hidden;
            pointer-events: none; z-index: 2;
        }
        #viewer-overlay {
            color: #CC0000; font-weight: bold; font-family: sans-serif;
            font-size: 40px; text-shadow: 1px 1px 2px #000;
            display: inline-block; white-space: nowrap;
            will-change: transform; opacity: 0;
        }
        #reward-overlay {
		position: absolute; top: 50%; left: 50%; transform: translate(--50%, -50%);
		background-color: rgba(0, 0, 0, 0.85); color: #FF0000; font-weight: bold;
		/* Giảm cỡ chữ cơ bản một chút để cân đối hơn */
		font-size: 36px; 
		padding: 30px 60px; border-radius: 15px;
		opacity: 0; transition: opacity 0.5s ease-in-out; text-align: center;
		z-index: 1000;
		width: 80vw;
		box-sizing: border-box;
		}

		/* Thêm lớp CSS mới này vào */
		.reward-score {
		font-size: 72px;  /* Cỡ chữ gấp đôi (36px * 2) */
		font-weight: bold;
		color: #FFFF00;   /* Màu vàng cho nổi bật */
		line-height: 1.1; /* Giảm khoảng cách dòng cho chữ lớn */
		margin-top: 8px;  /* Tạo chút khoảng cách với dòng phía trên */
		}

		.single-line-ellipsis {
		display: block;
		white-space: nowrap;
		overflow: hidden;
		text-overflow: ellipsis;
		}
    </style>
    <script>
        (function () {
            let styleEl;
            function injectKeyframes(distance) {
                if (!styleEl) {
                    styleEl = document.createElement('style');
                    styleEl.id = 'marquee-style';
                    document.head.appendChild(styleEl);
                }
                styleEl.textContent = `@keyframes marqueeAnim { 0% { transform: translateX(0); } 100% { transform: translateX(${distance}px); } }`;
            }
            window.setMarquee = function () {
                const textEl = document.getElementById('viewer-overlay');
                if (!textEl) return;
                const screenWidth = window.innerWidth;
                const textWidth = textEl.scrollWidth;
                const distance = screenWidth - textWidth;
                const duration = Math.max(6000, Math.min(40000, Math.abs(distance) * 12));
                injectKeyframes(distance);
                textEl.style.animation = `marqueeAnim ${duration}ms linear infinite alternate`;
            };
            window.addEventListener('resize', () => {
                clearTimeout(window.__marqueeResizeTimer);
                window.__marqueeResizeTimer = setTimeout(window.setMarquee, 150);
            });
        })();
    </script>
</head>
<body>

<div id="player"></div>
<div id="overlay-container"><div id="viewer-overlay"></div></div>
<div id="reward-overlay"></div>

<script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script src="https://www.youtube.com/iframe_api"></script>
<script>
    // === 1. THAY ĐỔI NAMESPACE ĐỂ KHỚP VỚI VIEWMODEL MỚI ===
    const CUSTOM_NAMESPACE = "urn:x-cast:com.tranduyen.chieuyoutube.custom";
    
    const context = cast.framework.CastReceiverContext.getInstance();
    const playerManager = context.getPlayerManager();
    const viewerOverlay = document.getElementById('viewer-overlay');
    const rewardOverlay = document.getElementById('reward-overlay');
    let ytPlayer;
    let isYouTubeReady = false;
    let currentViewerName = null; // Lưu tên ca sỹ hiện tại để hiển thị khen thưởng

    function log(message) {
        console.log('[YouTube Receiver]', message);
    }

    // --- Thiết lập YouTube Player ---
    window.onYouTubeIframeAPIReady = function() {
        log('YouTube IFrame API ready');
        ytPlayer = new YT.Player('player', {
            height: '100%', width: '100%',
            playerVars: { 'autoplay': 1, 'controls': 1, 'rel': 0 },
            events: { 
                'onStateChange': onPlayerStateChange,
                'onReady': onPlayerReady,
                'onError': onPlayerError
            }
        });
    };

    function onPlayerReady(event) {
        log('YouTube Player ready');
        isYouTubeReady = true;
    }

    function onPlayerError(event) {
        log(`Youtubeer error: ${event.data}`);
    }

    // === 2. ĐƠN GIẢN HÓA LOGIC KHI VIDEO KẾT THÚC ===
    // Receiver chỉ cần báo cáo là video đã kết thúc, không tự quyết định chuyển bài nữa.
    // --- SAU KHI SỬA ---
function onPlayerStateChange(event) {
    log(`Player state: ${event.data}`);
    if (event.data === YT.PlayerState.ENDED) {
        log('Video ended. Displaying reward and setting a delay before notifying sender.');
        viewerOverlay.style.opacity = 0;
        viewerOverlay.style.animation = "none";
        
        // Hiển thị khen thưởng nếu có
        if (currentViewerName) {
            showRewardMessage(currentViewerName);
        }
        
        // <<< THAY ĐỔI QUAN TRỌNG Ở ĐÂY >>>
        // Đợi 4 giây để người dùng xem thông báo rồi mới báo cho ViewModel
        setTimeout(() => {
            log('Delay finished. Notifying sender to play next video.');
            const message = { type: "VIDEO_ENDED" };
            context.sendCustomMessage(CUSTOM_NAMESPACE, undefined, message);
        }, 9000); // 9000 mili-giây = 9 giây
    }
}

    // === 3. VIẾT LẠI HOÀN TOÀN BỘ LẮNG NGHE LỆNH TÙY CHỈNH ===
    // Chỉ lắng nghe các lệnh mà ViewModel mới gửi: JUMP_TO và PLAY_NEXT
    context.addCustomMessageListener(CUSTOM_NAMESPACE, event => {
        const data = event.data;
        log(`Received custom message: ${JSON.stringify(data)}`);
        
        // Cả hai lệnh JUMP_TO và PLAY_NEXT đều có cùng cấu trúc và hành động
        if (data.type === "JUMP_TO" || data.type === "PLAY_NEXT") {
            if (data.media) {
                log(`Executing command '${data.type}' for video: ${data.media.contentId}`);
                loadVideoFromMessage(data.media);
            }
        }
    });

    // Hàm trợ giúp để tải video từ tin nhắn (dùng cho JUMP_TO và PLAY_NEXT)
    function showRewardMessage(viewerName) {
    // <<< THAY ĐỔI 1: Bắt đầu đếm từ 20 >>>
    const startScore = 20;
    const finalScore = Math.floor(Math.random() * 11) + 90; // Vẫn là số ngẫu nhiên 90-100
    let currentScore = startScore;

    rewardOverlay.innerHTML =
        `<div class="single-line-ellipsis">Ca sỹ ${viewerName} đã thể hiện bài hát rất tốt,</div>` +
        `<div class="single-line-ellipsis">điểm khen ngợi</div>` +
        `<div class="reward-score"><span id="score-counter">${startScore}</span> điểm</div>`;

    const scoreElement = document.getElementById('score-counter');

    rewardOverlay.style.opacity = 1;
    log(`Showing reward message for ${viewerName}. Counting from ${startScore} to ${finalScore}`);

    const counterInterval = setInterval(() => {
        if (currentScore < finalScore) {
            currentScore++;
            scoreElement.textContent = currentScore;
        } else {
            clearInterval(counterInterval);
        }
    }, 50);

    // <<< THAY ĐỔI 2: Thời gian hiển thị là 10 giây >>>
    setTimeout(() => {
        rewardOverlay.style.opacity = 0;
        clearInterval(counterInterval);
        log('Reward message hidden');
    }, 10000); // 10000 mili-giây = 10 giây
}

    // --- Xử lý các lệnh Cast chuẩn ---
    // Lệnh LOAD vẫn cần thiết cho lần phát đầu tiên do ViewModel gọi remoteMediaClient.load()
    playerManager.setMessageInterceptor(
        cast.framework.messages.MessageType.LOAD,
        loadRequestData => {
            log('Standard LOAD command received for the first video.');
            if (loadRequestData.media) {
                loadVideoFromMessage(loadRequestData.media);
            }
            return null; // Chặn xử lý mặc định
        }
    );

    playerManager.setMessageInterceptor(
        cast.framework.messages.MessageType.PLAY,
        () => { if (ytPlayer) ytPlayer.playVideo(); return null; }
    );

    playerManager.setMessageInterceptor(
        cast.framework.messages.MessageType.PAUSE,
        () => { if (ytPlayer) ytPlayer.pauseVideo(); return null; }
    );

    // === 4. LOẠI BỎ CÁC HÀM KHÔNG CẦN THIẾT ===
    // Các hàm sendCurrentStatus, handleQueueAdvance đã bị loại bỏ vì Sender quản lý hết.
    
    function showRewardMessage(viewerName) {
    const startScore = 80;
    const finalScore = Math.floor(Math.random() * 11) + 90; // Tạo số ngẫu nhiên từ 90-100
    let currentScore = startScore;

    // 1. Tạo cấu trúc HTML ban đầu với một thẻ <span> để chứa điểm số
    //    Điều này cho phép chúng ta cập nhật chỉ riêng con số mà không ảnh hưởng đến phần còn lại.
    rewardOverlay.innerHTML = `Ca sỹ ${viewerName} đã thể hiện bài hát rất tốt,<br>điểm khen ngợi <span id="score-counter">${startScore}</span> điểm.`;
    const scoreElement = document.getElementById('score-counter');

    // 2. Hiển thị hộp thoại
    rewardOverlay.style.opacity = 1;
    log(`Showing reward message for ${viewerName}. Counting from ${startScore} to ${finalScore}`);

    // 3. Bắt đầu hiệu ứng đếm số
    const counterInterval = setInterval(() => {
        // Nếu điểm hiện tại chưa bằng điểm cuối cùng thì tiếp tục đếm
        if (currentScore < finalScore) {
            currentScore++; // Tăng điểm lên 1
            scoreElement.textContent = currentScore; // Cập nhật con số trên màn hình
        } else {
            // Nếu đã đếm tới nơi, dừng bộ đếm
            clearInterval(counterInterval);
        }
    }, 50); // Tốc độ đếm: cập nhật số mới sau mỗi 50 mili-giây

    // 4. Đặt hẹn giờ để ẩn toàn bộ thông báo sau 5 giây
    setTimeout(() => {
        rewardOverlay.style.opacity = 0;
        // Đảm bảo dừng bộ đếm phòng trường hợp nó chưa dừng
        clearInterval(counterInterval);
        log('Reward message hidden');
    }, 5000);
}

    // Khởi động Cast receiver
    const options = new cast.framework.CastReceiverOptions();
    options.disableIdleTimeout = true;
    context.start(options);
    log('Cast receiver started');
</script>
</body>
</html>
