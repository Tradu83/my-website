<!DOCTYPE html>
<html lang="vi">
<head>
	<meta charset="UTF-8">
	<title>Chiếu YouTube Receiver</title>
	<style>
		html, body {
			margin: 0; padding: 0; width: 100%; height: 100%;
			background-color: #000; overflow: hidden;
		}
		#player { width: 100vw; height: 100vh; }
		#viewer-overlay {
			position: absolute; top: 20px; left: 0; width: 100%;
			color: #CC0000; font-weight: bold; font-family: sans-serif;
			font-size: 40px; text-shadow: 1px 1px 2px #000;
			text-align: center; opacity: 0; transition: opacity 0.5s;
			z-index: 1000; pointer-events: none;
		}
		#reward-overlay {
			position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
			background-color: rgba(0, 0, 0, 0.85); color: #FF0000;
			font-weight: bold; font-size: 48px; padding: 30px 60px;
			border-radius: 15px; opacity: 0; transition: opacity 0.5s ease-in-out;
			text-align: center; z-index: 1000;
		}
	</style>
</head>
<body>

<div id="player"></div>
<div id="viewer-overlay"></div>
<div id="reward-overlay"></div>

<script src="//www.gstatic.com/cast/sdk/libs/caf_receiver/v3/cast_receiver_framework.js"></script>
<script src="https://www.youtube.com/iframe_api"></script>
<script>
	const CUSTOM_NAMESPACE = "urn:x-cast:com.tranduyen.chieuyoutube.control";
	const context = cast.framework.CastReceiverContext.getInstance();
	const playerManager = context.getPlayerManager();
	const queueManager = playerManager.getQueueManager();
	const viewerOverlay = document.getElementById('viewer-overlay');
	const rewardOverlay = document.getElementById('reward-overlay');
	let ytPlayer;
	let isYouTubeReady = false;
	let currentVideoId = null;
	let currentMediaItem = null;
	let currentRepeatMode = cast.framework.messages.RepeatMode.OFF;

	function log(message) { console.log('[YouTube Receiver]', message); }

	// YouTube Player - giống test_cast_receiver.html
	window.onYouTubeIframeAPIReady = function() {
		log('YouTube IFrame API ready');
		ytPlayer = new YT.Player('player', {
			height: '100%', width: '100%',
			playerVars: { 'autoplay': 1, 'controls': 1, 'rel': 0 },
			events: { 
				'onStateChange': onPlayerStateChange,
				'onReady': onPlayerReady,
				'onError': onPlayerError
			}
		});
	};

	function onPlayerReady() {
		log('YouTube Player ready');
		isYouTubeReady = true;
	}
	function onPlayerError(event) { log(`YouTube Player error: ${event.data}`); }

	function onPlayerStateChange(event) {
		log(`Player state: ${event.data}`);
		if (event.data === YT.PlayerState.ENDED) {
			log('Video ended');
			viewerOverlay.style.opacity = 0;

			const curItem = queueManager.getCurrentItem();
			if (curItem?.media?.customData?.viewerName) showRewardMessage(curItem);

			setTimeout(() => { handleQueueAdvance(); }, 1200);
		} else if (event.data === YT.PlayerState.PLAYING) {
			log('Video started playing');
			sendCurrentStatus();
		}
	}

	function playMediaItem(item) {
		if (!item) { log('No item to play'); return; }
		currentMediaItem = item;
		const videoId = item.media.contentId;
		const customData = item.media.customData || {};
		currentVideoId = videoId;
		log(`playMediaItem -> ${videoId}`);

		if (isYouTubeReady && ytPlayer && videoId) {
			ytPlayer.loadVideoById({ videoId, suggestedQuality: 'hd1080' });
		} else {
			log('YouTube player not ready for playMediaItem');
		}

		if (customData.viewerName) {
			viewerOverlay.textContent = `Ca sỹ trình bày: ${customData.viewerName}`;
			viewerOverlay.style.opacity = 1;
		} else {
			viewerOverlay.textContent = '';
			viewerOverlay.style.opacity = 0;
		}
		sendCurrentStatus();
	}

	function handleQueueAdvance() {
		log(`handleQueueAdvance, repeat=${currentRepeatMode}`);
		if (currentRepeatMode === cast.framework.messages.RepeatMode.SINGLE) {
			if (isYouTubeReady && ytPlayer) { ytPlayer.seekTo(0); ytPlayer.playVideo(); }
			return;
		}
		const nextItem = queueManager.getNextItem();
		if (nextItem) {
			const nextIndex = queueManager.getCurrentItemIndex() + 1;
			queueManager.jumpToItem(nextIndex);
			playMediaItem(nextItem);
			return;
		}
		if (currentRepeatMode === cast.framework.messages.RepeatMode.ALL) {
			const firstItem = queueManager.getQueue()[0];
			if (firstItem) { queueManager.jumpToItem(0); playMediaItem(firstItem); }
		}
	}

	// Interceptors
	playerManager.setMessageInterceptor(
		cast.framework.messages.MessageType.LOAD,
		loadRequestData => {
			const media = loadRequestData.media;
			const videoId = media.contentId;
			const customData = media.customData || {};
			log(`LOAD: ${videoId}`);
			currentVideoId = videoId;
			if (isYouTubeReady && ytPlayer && videoId) {
				ytPlayer.loadVideoById({ videoId, suggestedQuality: 'hd1080' });
			} else {
				log('YouTube not ready for LOAD');
			}
			if (customData.viewerName) { viewerOverlay.textContent = `Ca sỹ trình bày: ${customData.viewerName}`; viewerOverlay.style.opacity = 1; }
			else { viewerOverlay.textContent = ''; viewerOverlay.style.opacity = 0; }
			sendCurrentStatus();
			return null;
		}
	);

	playerManager.setMessageInterceptor(
		cast.framework.messages.MessageType.PLAY,
		() => { if (isYouTubeReady && ytPlayer) ytPlayer.playVideo(); return null; }
	);
	playerManager.setMessageInterceptor(
		cast.framework.messages.MessageType.PAUSE,
		() => { if (isYouTubeReady && ytPlayer) ytPlayer.pauseVideo(); return null; }
	);
	playerManager.setMessageInterceptor(
		cast.framework.messages.MessageType.QUEUE_NEXT,
		() => { log('QUEUE_NEXT'); handleQueueAdvance(); return null; }
	);
	playerManager.setMessageInterceptor(
		cast.framework.messages.MessageType.QUEUE_PREV,
		() => {
			log('QUEUE_PREV');
			const prevItem = queueManager.getPreviousItem();
			if (prevItem) {
				const prevIndex = Math.max(0, queueManager.getCurrentItemIndex() - 1);
				queueManager.jumpToItem(prevIndex);
				playMediaItem(prevItem);
			}
			return null;
		}
	);

	// Custom messages từ Sender
	context.addCustomMessageListener(CUSTOM_NAMESPACE, event => {
		const data = event.data || {};
		log(`Custom message: ${JSON.stringify(data)}`);
		if (data.type === 'setRepeatMode') {
			currentRepeatMode = data.mode;
			try { queueManager.setRepeatMode?.(currentRepeatMode); } catch(e) {}
			sendCurrentStatus();
			return;
		}
		if (data.cmd === 'playById') {
			const queue = queueManager.getQueue();
			for (let i = 0; i < queue.length; i++) {
				const item = queue[i];
				if (item.media.contentId === data.videoId) {
					queueManager.jumpToItem(i);
					playMediaItem(item);
					break;
				}
			}
			return;
		}
		if (data.cmd === 'playNext') { handleQueueAdvance(); return; }
		if (data.event === 'syncQueue') { sendCurrentStatus(); return; }
	});

	function sendCurrentStatus() {
		const currentItem = queueManager.getCurrentItem();
		const videoId = currentItem?.media?.contentId || currentVideoId;
		const status = { type: 'statusUpdate', repeatMode: currentRepeatMode, currentlyPlayingVideoId: videoId };
		log(`Send status: ${JSON.stringify(status)}`);
		context.sendCustomMessage(CUSTOM_NAMESPACE, undefined, status);
	}

	function showRewardMessage(item) {
		if (item?.media?.customData?.viewerName) {
			const viewerName = item.media.customData.viewerName;
			const score = Math.floor(Math.random() * 11) + 90;
			rewardOverlay.innerHTML = `Ca sỹ ${viewerName} đã thể hiện bài hát rất tốt,<br>điểm khen ngợi ${score} điểm.`;
			rewardOverlay.style.opacity = 1;
			setTimeout(() => { rewardOverlay.style.opacity = 0; }, 3500);
		}
	}

	const options = new cast.framework.CastReceiverOptions();
	options.disableIdleTimeout = true;
	context.start(options);
	log('Cast receiver started');
</script>
</body>
</html>
